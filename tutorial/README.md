- https://flask.palletsprojects.com/en/1.1.x/tutorial/

# 튜토리얼

이미 Python에 익숙하다고 가정합니다. Python 문서의 공식 자습서는 먼저 배우거나 검토 할 수있는 좋은 방법입니다.

좋은 시작점을 제공하도록 설계되었지만이 튜토리얼에서 Flask의 모든 기능을 다루지는 않습니다. Flask가 수행 할 수있는 작업에 대한 개요는 빠른 시작을 확인한 다음 문서에서 자세히 알아보세요. 이 가이드에서는 Flask 및 Python에서 제공하는 것만 사용합니다. 다른 프로젝트에서는 일부 작업을 더 간단하게 만들기 위해 Extensions 또는 기타 라이브러리를 사용할 수 있습니다.

플라스크는 유연합니다. 특정 프로젝트 또는 코드 레이아웃을 사용할 필요가 없습니다. 그러나 처음 시작할 때는보다 체계적인 접근 방식을 사용하는 것이 좋습니다. 즉, 가이드에는 약간의 상용구가 필요하지만 새로운 개발자가 직면하는 많은 일반적인 함정을 피하기 위해 수행되었으며 확장하기 쉬운 프로젝트를 만듭니다. Flask에 익숙해지면이 구조에서 벗어나 Flask의 유연성을 최대한 활용할 수 있습니다.

튜토리얼을 수행하면서 프로젝트를 최종 제품과 비교하려는 경우 튜토리얼 프로젝트는 Flask 저장소에서 예제로 사용할 수 있습니다.

프로젝트 레이아웃으로 계속합니다.

## 프로젝트 레이아웃

Python 가상 환경을 설정하고 프로젝트에 Flask를 설치합니다.

이 자습서에서는 지금부터 flask-tutorial 디렉터리에서 작업한다고 가정합니다. 각 코드 블록의 맨 위에있는 파일 이름은이 디렉토리에 상대적입니다.

그러나 프로젝트가 커질수록 모든 코드를 하나의 파일에 보관하는 것은 부담스러워집니다. Python 프로젝트는 패키지를 사용하여 필요한 곳에 가져올 수있는 여러 모듈로 코드를 구성하며, 튜토리얼에서도이 작업을 수행합니다.

프로젝트 디렉토리에는 다음이 포함됩니다.

flaskr /, 애플리케이션 코드와 파일을 포함하는 Python 패키지.
tests /, 테스트 모듈을 포함하는 디렉토리.
venv /, Flask 및 기타 종속성이 설치된 Python 가상 환경.

Python에 프로젝트 설치 방법을 알려주는 설치 파일.

git과 같은 버전 제어 구성 크기에 관계없이 모든 프로젝트에 대해 몇 가지 유형의 버전 제어를 사용하는 습관을 만들어야합니다.

나중에 추가 할 수있는 기타 프로젝트 파일.

결국 프로젝트 레이아웃은 다음과 같습니다.

```
/home/user/Projects/flask-tutorial
├── flaskr/
│   ├── __init__.py
│   ├── db.py
│   ├── schema.sql
│   ├── auth.py
│   ├── blog.py
│   ├── templates/
│   │   ├── base.html
│   │   ├── auth/
│   │   │   ├── login.html
│   │   │   └── register.html
│   │   └── blog/
│   │       ├── create.html
│   │       ├── index.html
│   │       └── update.html
│   └── static/
│       └── style.css
├── tests/
│   ├── conftest.py
│   ├── data.sql
│   ├── test_factory.py
│   ├── test_db.py
│   ├── test_auth.py
│   └── test_blog.py
├── venv/
├── setup.py
└── MANIFEST.in
```

- flaskr /, 애플리케이션 코드와 파일을 포함하는 Python 패키지.
- tests /, 테스트 모듈을 포함하는 디렉토리.
- venv /, Flask 및 기타 종속성이 설치된 Python 가상 환경.
- Python에 프로젝트 설치 방법을 알려주는 설치 파일.
- git과 같은 버전 제어 구성 크기에 관계없이 모든 프로젝트에 대해 몇 가지 유형의 버전 제어를 사용하는 습관을 만들어야합니다.

나중에 추가 할 수있는 기타 프로젝트 파일.


버전 제어를 사용하는 경우 프로젝트를 실행하는 동안 생성되는 다음 파일은 무시해야합니다. 사용하는 편집기에 따라 다른 파일이있을 수 있습니다. 일반적으로 작성하지 않은 파일은 무시하십시오. 예를 들어 git의 경우 :

```
.gitignore
venv/

*.pyc
__pycache__/

instance/

.pytest_cache/
.coverage
htmlcov/

dist/
build/
*.egg-info/
```

## 앱 설정

Flask 애플리케이션은 Flask 클래스의 인스턴스입니다. 구성 및 URL과 같은 응용 프로그램에 대한 모든 것이 이 클래스에 등록됩니다.

Flask 애플리케이션을 만드는 가장 간단한 방법은 "Hello, World!"와 같이 코드 상단에 직접 전역 Flask 인스턴스를 만드는 것입니다. 예제는 이전 페이지에서했습니다. 어떤 경우에는 간단하고 유용하지만 프로젝트가 성장함에 따라 까다로운 문제가 발생할 수 있습니다.

Flask 인스턴스를 전역 적으로 생성하는 대신 함수 내부에 생성합니다. 이 기능을 애플리케이션 팩토리라고합니다. 응용 프로그램에 필요한 모든 구성, 등록 및 기타 설정이 함수 내에서 발생하고 응용 프로그램이 반환됩니다.

### 애플리케이션 팩토리

코딩을 시작할 시간입니다! flaskr 디렉토리를 만들고 __init__.py 파일을 추가합니다. __init__.py는 이중 역할을 수행합니다. 애플리케이션 팩토리를 포함하고 Python에 flaskr 디렉토리를 패키지로 처리해야한다고 알려줍니다.


### 앱 실행
- visual stduio settings.json의 적절한 세팅 이후 실행

## 데이터베이스 정의 및 액세스

응용 프로그램은 SQLite 데이터베이스를 사용하여 사용자와 게시물을 저장합니다. Python은 sqlite3 모듈에서 SQLite를 기본적으로 지원합니다.

SQLite는 별도의 데이터베이스 서버를 설정할 필요가 없고 Python에 내장되어 있어 편리합니다. 그러나 동시 요청이 동시에 데이터베이스에 쓰려고하면 각 쓰기가 순차적으로 발생하므로 속도가 느려집니다. 소규모 응용 프로그램에서는 이를 인식하지 못합니다. 일단 커지면 다른 데이터베이스로 전환 할 수 있습니다.

이 자습서에서는 SQL에 대해 자세히 설명하지 않습니다. 익숙하지 않은 경우 SQLite 문서에서 언어를 설명합니다.

### 데이터베이스 접속

SQLite 데이터베이스 (및 대부분의 다른 Python 데이터베이스 라이브러리)로 작업 할 때 가장 먼저해야 할 일은 연결을 만드는 것입니다. 모든 쿼리 및 작업은 연결을 사용하여 수행되며 작업이 완료된 후 닫힙니다.

웹 애플리케이션에서이 연결은 일반적으로 요청에 연결됩니다. 요청을 처리 할 때 생성되고 응답이 전송되기 전에 닫힙니다.

g는 각 요청에 대해 고유 한 특수 개체입니다. 요청 중에 여러 기능에서 액세스 할 수 있는 데이터를 저장하는 데 사용됩니다. 동일한 요청에서 get_db를 두 번 호출하면 새 연결을 만드는 대신 연결이 저장되고 재사용됩니다.

current_app은 요청을 처리하는 Flask 애플리케이션을 가리키는 또 다른 특수 개체입니다. 애플리케이션 팩토리를 사용했기 때문에 나머지 코드를 작성할 때 애플리케이션 객체가 없습니다. get_db는 애플리케이션이 생성되고 요청을 처리 할 때 호출되므로 current_app을 사용할 수 있습니다.


### 테이블 생성

SQLite에서 데이터는 테이블과 열에 저장됩니다. 데이터를 저장하고 검색하려면 먼저 생성해야합니다. Flaskr은 사용자를 user 테이블에 저장하고 post 테이블에 게시합니다. 빈 테이블을 만드는 데 필요한 SQL 명령으로 파일을 만듭니다.

스키마 파일을 만들어서 해당 스키마를 실행할 수 있음.

### 응용 프로그램에 등록

close_db 및 init_db_command 함수는 응용 프로그램 인스턴스에 등록해야 합니다. 그렇지 않으면 응용 프로그램에서 사용되지 않습니다. 그러나 팩토리 함수를 사용 중이므로 함수를 작성할 때 해당 인스턴스를 사용할 수 없습니다. 대신 응용 프로그램을 받아 등록하는 함수를 작성하십시오.

### 데이터 베이스 파일 초기화
이제 init-db가 앱에 등록 되었으므로 이전 페이지의 실행 명령과 유사한 flask 명령을 사용하여 호출 할 수 있습니다.

```bash
set FLASK_APP=flasr
set FLASK_ENV=development
flask init-db
```

## 블루프린트와 뷰

뷰 함수는 애플리케이션에 대한 요청에 응답하기 위해 작성하는 코드입니다. Flask는 패턴을 사용하여 수신 요청 URL을 처리해야하는 뷰에 일치시킵니다. 뷰는 Flask가 발신 응답으로 변환하는 데이터를 반환합니다. Flask는 다른 방향으로 이동하여 이름과 인수를 기반으로 뷰에 대한 URL을 생성 할 수도 있습니다.

### 블루프린트 생성

블루프린트는 관련 뷰 및 기타 코드 그룹을 구성하는 방법입니다. 뷰 및 기타 코드를 애플리케이션에 직접 등록하는 대신 블루프린트에 등록합니다. 그런 다음 팩토리 기능에서 사용할 수 있을 때 블루프린트를 응용 프로그램에 등록됩니다.

Flaskr에는 두 개의 블루프린트가 있는데 하나는 인증 기능 용이고 다른 하나는 블로그 게시물 기능 용입니다. 각 블루프린트의 코드는 별도의 모듈에 들어갑니다. 블로그에서 인증에 대해 알아야 하므로 먼저 인증을 작성합니다.

app.register_blueprint()를 사용하여 팩토리에서 블루프린트를 가져오고 등록합니다. 앱을 반환하기 전에 공장 기능 끝에 새 코드를 배치합니다.

### 첫번째 뷰 : 등록

사용자가 /auth/register URL을 방문하면 등록 보기에서 양식을 작성할 수 있는 HTML을 반환합니다. 양식을 제출하면 입력을 확인하고 오류 메시지와 함께 양식을 다시 표시하거나 새 사용자를 만들고 로그인 페이지로 이동합니다.

지금은보기 코드 만 작성합니다. 다음 페이지에서는 HTML 양식을 생성하는 템플릿을 작성합니다.

### 로그인

이보기는 위의 레지스터보기와 동일한 패턴을 따릅니다.

### 로그아웃

로그 아웃하려면 세션에서 사용자 ID를 제거해야합니다. 그러면 load_logged_in_user가 후속 요청에서 사용자를 로드하지 않습니다.

### 다른 뷰에서 인증

블로그 게시물을 만들고 편집하고 삭제하려면 사용자가 로그인해야합니다. 데코레이터를 사용하여 적용되는 각 보기에 대해 이를 확인할 수 있습니다.

### 엔드포인트 URLs

url_for() 함수는 이름과 인수를 기반으로 뷰에 대한 URL을 생성합니다. 보기와 관련된 이름을 끝점 이라고도하며 기본적으로 보기 함수의 이름과 동일합니다.

예를 들어 튜토리얼의 앞부분에서 앱 팩토리에 추가 된 hello() 뷰는 'hello'라는 이름을 가지며 url_for('hello')로 링크 될 수 있습니다. 나중에 보시게 될 인수를 받으면 url_for('hello', who='World')를 사용하여 연결됩니다.

블루 프린트를 사용하는 경우 블루 프린트 이름이 함수 이름 앞에 추가되므로 위에서 작성한 로그인 함수의 엔드 포인트는 'auth' 블루 프린트에 추가했기 때문에 'auth.login' 입니다.
