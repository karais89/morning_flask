- https://flask.palletsprojects.com/en/1.1.x/tutorial/

# 튜토리얼

이미 Python에 익숙하다고 가정합니다. Python 문서의 공식 자습서는 먼저 배우거나 검토 할 수있는 좋은 방법입니다.

좋은 시작점을 제공하도록 설계되었지만이 튜토리얼에서 Flask의 모든 기능을 다루지는 않습니다. Flask가 수행 할 수있는 작업에 대한 개요는 빠른 시작을 확인한 다음 문서에서 자세히 알아보세요. 이 가이드에서는 Flask 및 Python에서 제공하는 것만 사용합니다. 다른 프로젝트에서는 일부 작업을 더 간단하게 만들기 위해 Extensions 또는 기타 라이브러리를 사용할 수 있습니다.

플라스크는 유연합니다. 특정 프로젝트 또는 코드 레이아웃을 사용할 필요가 없습니다. 그러나 처음 시작할 때는보다 체계적인 접근 방식을 사용하는 것이 좋습니다. 즉, 가이드에는 약간의 상용구가 필요하지만 새로운 개발자가 직면하는 많은 일반적인 함정을 피하기 위해 수행되었으며 확장하기 쉬운 프로젝트를 만듭니다. Flask에 익숙해지면이 구조에서 벗어나 Flask의 유연성을 최대한 활용할 수 있습니다.

튜토리얼을 수행하면서 프로젝트를 최종 제품과 비교하려는 경우 튜토리얼 프로젝트는 Flask 저장소에서 예제로 사용할 수 있습니다.

프로젝트 레이아웃으로 계속합니다.

## 프로젝트 레이아웃

Python 가상 환경을 설정하고 프로젝트에 Flask를 설치합니다.

이 자습서에서는 지금부터 flask-tutorial 디렉터리에서 작업한다고 가정합니다. 각 코드 블록의 맨 위에있는 파일 이름은이 디렉토리에 상대적입니다.

그러나 프로젝트가 커질수록 모든 코드를 하나의 파일에 보관하는 것은 부담스러워집니다. Python 프로젝트는 패키지를 사용하여 필요한 곳에 가져올 수있는 여러 모듈로 코드를 구성하며, 튜토리얼에서도이 작업을 수행합니다.

프로젝트 디렉토리에는 다음이 포함됩니다.

flaskr /, 애플리케이션 코드와 파일을 포함하는 Python 패키지.
tests /, 테스트 모듈을 포함하는 디렉토리.
venv /, Flask 및 기타 종속성이 설치된 Python 가상 환경.

Python에 프로젝트 설치 방법을 알려주는 설치 파일.

git과 같은 버전 제어 구성 크기에 관계없이 모든 프로젝트에 대해 몇 가지 유형의 버전 제어를 사용하는 습관을 만들어야합니다.

나중에 추가 할 수있는 기타 프로젝트 파일.

결국 프로젝트 레이아웃은 다음과 같습니다.

```
/home/user/Projects/flask-tutorial
├── flaskr/
│   ├── __init__.py
│   ├── db.py
│   ├── schema.sql
│   ├── auth.py
│   ├── blog.py
│   ├── templates/
│   │   ├── base.html
│   │   ├── auth/
│   │   │   ├── login.html
│   │   │   └── register.html
│   │   └── blog/
│   │       ├── create.html
│   │       ├── index.html
│   │       └── update.html
│   └── static/
│       └── style.css
├── tests/
│   ├── conftest.py
│   ├── data.sql
│   ├── test_factory.py
│   ├── test_db.py
│   ├── test_auth.py
│   └── test_blog.py
├── venv/
├── setup.py
└── MANIFEST.in
```

- flaskr /, 애플리케이션 코드와 파일을 포함하는 Python 패키지.
- tests /, 테스트 모듈을 포함하는 디렉토리.
- venv /, Flask 및 기타 종속성이 설치된 Python 가상 환경.
- Python에 프로젝트 설치 방법을 알려주는 설치 파일.
- git과 같은 버전 제어 구성 크기에 관계없이 모든 프로젝트에 대해 몇 가지 유형의 버전 제어를 사용하는 습관을 만들어야합니다.

나중에 추가 할 수있는 기타 프로젝트 파일.


버전 제어를 사용하는 경우 프로젝트를 실행하는 동안 생성되는 다음 파일은 무시해야합니다. 사용하는 편집기에 따라 다른 파일이있을 수 있습니다. 일반적으로 작성하지 않은 파일은 무시하십시오. 예를 들어 git의 경우 :

```
.gitignore
venv/

*.pyc
__pycache__/

instance/

.pytest_cache/
.coverage
htmlcov/

dist/
build/
*.egg-info/
```

## 앱 설정

Flask 애플리케이션은 Flask 클래스의 인스턴스입니다. 구성 및 URL과 같은 응용 프로그램에 대한 모든 것이 이 클래스에 등록됩니다.

Flask 애플리케이션을 만드는 가장 간단한 방법은 "Hello, World!"와 같이 코드 상단에 직접 전역 Flask 인스턴스를 만드는 것입니다. 예제는 이전 페이지에서했습니다. 어떤 경우에는 간단하고 유용하지만 프로젝트가 성장함에 따라 까다로운 문제가 발생할 수 있습니다.

Flask 인스턴스를 전역 적으로 생성하는 대신 함수 내부에 생성합니다. 이 기능을 애플리케이션 팩토리라고합니다. 응용 프로그램에 필요한 모든 구성, 등록 및 기타 설정이 함수 내에서 발생하고 응용 프로그램이 반환됩니다.

### 애플리케이션 팩토리

코딩을 시작할 시간입니다! flaskr 디렉토리를 만들고 __init__.py 파일을 추가합니다. __init__.py는 이중 역할을 수행합니다. 애플리케이션 팩토리를 포함하고 Python에 flaskr 디렉토리를 패키지로 처리해야한다고 알려줍니다.


### 앱 실행
- visual stduio settings.json의 적절한 세팅 이후 실행

## 데이터베이스 정의 및 액세스

응용 프로그램은 SQLite 데이터베이스를 사용하여 사용자와 게시물을 저장합니다. Python은 sqlite3 모듈에서 SQLite를 기본적으로 지원합니다.

SQLite는 별도의 데이터베이스 서버를 설정할 필요가 없고 Python에 내장되어 있어 편리합니다. 그러나 동시 요청이 동시에 데이터베이스에 쓰려고하면 각 쓰기가 순차적으로 발생하므로 속도가 느려집니다. 소규모 응용 프로그램에서는 이를 인식하지 못합니다. 일단 커지면 다른 데이터베이스로 전환 할 수 있습니다.

이 자습서에서는 SQL에 대해 자세히 설명하지 않습니다. 익숙하지 않은 경우 SQLite 문서에서 언어를 설명합니다.

### 데이터베이스 접속

SQLite 데이터베이스 (및 대부분의 다른 Python 데이터베이스 라이브러리)로 작업 할 때 가장 먼저해야 할 일은 연결을 만드는 것입니다. 모든 쿼리 및 작업은 연결을 사용하여 수행되며 작업이 완료된 후 닫힙니다.

웹 애플리케이션에서이 연결은 일반적으로 요청에 연결됩니다. 요청을 처리 할 때 생성되고 응답이 전송되기 전에 닫힙니다.

g는 각 요청에 대해 고유 한 특수 개체입니다. 요청 중에 여러 기능에서 액세스 할 수 있는 데이터를 저장하는 데 사용됩니다. 동일한 요청에서 get_db를 두 번 호출하면 새 연결을 만드는 대신 연결이 저장되고 재사용됩니다.

current_app은 요청을 처리하는 Flask 애플리케이션을 가리키는 또 다른 특수 개체입니다. 애플리케이션 팩토리를 사용했기 때문에 나머지 코드를 작성할 때 애플리케이션 객체가 없습니다. get_db는 애플리케이션이 생성되고 요청을 처리 할 때 호출되므로 current_app을 사용할 수 있습니다.


### 테이블 생성

SQLite에서 데이터는 테이블과 열에 저장됩니다. 데이터를 저장하고 검색하려면 먼저 생성해야합니다. Flaskr은 사용자를 user 테이블에 저장하고 post 테이블에 게시합니다. 빈 테이블을 만드는 데 필요한 SQL 명령으로 파일을 만듭니다.

스키마 파일을 만들어서 해당 스키마를 실행할 수 있음.

### 응용 프로그램에 등록

close_db 및 init_db_command 함수는 응용 프로그램 인스턴스에 등록해야 합니다. 그렇지 않으면 응용 프로그램에서 사용되지 않습니다. 그러나 팩토리 함수를 사용 중이므로 함수를 작성할 때 해당 인스턴스를 사용할 수 없습니다. 대신 응용 프로그램을 받아 등록하는 함수를 작성하십시오.

### 데이터 베이스 파일 초기화
이제 init-db가 앱에 등록 되었으므로 이전 페이지의 실행 명령과 유사한 flask 명령을 사용하여 호출 할 수 있습니다.

```bash
set FLASK_APP=flasr
set FLASK_ENV=development
flask init-db
```

## 블루프린트와 뷰

뷰 함수는 애플리케이션에 대한 요청에 응답하기 위해 작성하는 코드입니다. Flask는 패턴을 사용하여 수신 요청 URL을 처리해야하는 뷰에 일치시킵니다. 뷰는 Flask가 발신 응답으로 변환하는 데이터를 반환합니다. Flask는 다른 방향으로 이동하여 이름과 인수를 기반으로 뷰에 대한 URL을 생성 할 수도 있습니다.

### 블루프린트 생성

블루프린트는 관련 뷰 및 기타 코드 그룹을 구성하는 방법입니다. 뷰 및 기타 코드를 애플리케이션에 직접 등록하는 대신 블루프린트에 등록합니다. 그런 다음 팩토리 기능에서 사용할 수 있을 때 블루프린트를 응용 프로그램에 등록됩니다.

Flaskr에는 두 개의 블루프린트가 있는데 하나는 인증 기능 용이고 다른 하나는 블로그 게시물 기능 용입니다. 각 블루프린트의 코드는 별도의 모듈에 들어갑니다. 블로그에서 인증에 대해 알아야 하므로 먼저 인증을 작성합니다.

app.register_blueprint()를 사용하여 팩토리에서 블루프린트를 가져오고 등록합니다. 앱을 반환하기 전에 공장 기능 끝에 새 코드를 배치합니다.

### 첫번째 뷰 : 등록

사용자가 /auth/register URL을 방문하면 등록 보기에서 양식을 작성할 수 있는 HTML을 반환합니다. 양식을 제출하면 입력을 확인하고 오류 메시지와 함께 양식을 다시 표시하거나 새 사용자를 만들고 로그인 페이지로 이동합니다.

지금은보기 코드 만 작성합니다. 다음 페이지에서는 HTML 양식을 생성하는 템플릿을 작성합니다.

### 로그인

이보기는 위의 레지스터보기와 동일한 패턴을 따릅니다.

### 로그아웃

로그 아웃하려면 세션에서 사용자 ID를 제거해야합니다. 그러면 load_logged_in_user가 후속 요청에서 사용자를 로드하지 않습니다.

### 다른 뷰에서 인증

블로그 게시물을 만들고 편집하고 삭제하려면 사용자가 로그인해야합니다. 데코레이터를 사용하여 적용되는 각 보기에 대해 이를 확인할 수 있습니다.

### 엔드포인트 URLs

url_for() 함수는 이름과 인수를 기반으로 뷰에 대한 URL을 생성합니다. 보기와 관련된 이름을 끝점 이라고도하며 기본적으로 보기 함수의 이름과 동일합니다.

예를 들어 튜토리얼의 앞부분에서 앱 팩토리에 추가 된 hello() 뷰는 'hello'라는 이름을 가지며 url_for('hello')로 링크 될 수 있습니다. 나중에 보시게 될 인수를 받으면 url_for('hello', who='World')를 사용하여 연결됩니다.

블루 프린트를 사용하는 경우 블루 프린트 이름이 함수 이름 앞에 추가되므로 위에서 작성한 로그인 함수의 엔드 포인트는 'auth' 블루 프린트에 추가했기 때문에 'auth.login' 입니다.

## 템플릿

애플리케이션에 대한 인증보기를 작성했지만 서버를 실행하고 URL로 이동하려고하면 TemplateNotFound 오류가 표시됩니다. 뷰가 render_template ()을 호출하지만 아직 템플릿을 작성하지 않았기 때문입니다. 템플릿 파일은 flaskr 패키지 내의 templates 디렉토리에 저장됩니다.

템플릿은 정적 데이터와 동적 데이터에 대한 자리 표시자를 포함하는 파일입니다. 템플릿은 특정 데이터로 렌더링되어 최종 문서를 생성합니다. Flask는 Jinja 템플릿 라이브러리를 사용하여 템플릿을 렌더링합니다.

애플리케이션에서 템플릿을 사용하여 사용자의 브라우저에 표시되는 HTML을 렌더링합니다. Flask에서 Jinja는 HTML 템플릿에서 렌더링되는 모든 데이터를 자동 이스케이프하도록 구성되어 있습니다. 즉, 사용자 입력을 렌더링하는 것이 안전합니다. HTML을 엉망으로 만들 수있는 문자 (예 : <및>)는 브라우저에서 동일하게 보이지만 원치 않는 효과를 일으키지 않는 안전한 값으로 이스케이프됩니다.

Jinja는 대부분 Python처럼 보이고 동작합니다. Jinja 구문을 템플릿의 정적 데이터와 구별하기 위해 특수 구분 기호가 사용됩니다. {{와}} 사이의 모든 것은 최종 문서에 출력 될 표현식입니다. {% 및 %}는 if 및 for와 같은 제어 흐름 문을 나타냅니다. Python과는 달리 블록 내의 정적 텍스트는 들여 쓰기를 변경할 수 있으므로 들여 쓰기가 아닌 시작 및 종료 태그로 블록을 표시합니다.

### 기본 레이아웃

응용 프로그램의 각 페이지는 다른 본문 주위에 동일한 기본 레이아웃을 갖습니다. 각 템플릿에 전체 HTML 구조를 작성하는 대신 각 템플릿은 기본 템플릿을 확장하고 특정 섹션을 재정의합니다


#### Base 템플릿

g는 템플릿에서 자동으로 사용할 수 있습니다. g.user가 설정된 경우 (load_logged_in_user에서) 사용자 이름과 로그 아웃 링크가 표시되거나 등록 및 로그인 링크가 표시됩니다. url_for ()도 자동으로 사용할 수 있으며 수동으로 작성하는 대신 뷰에 대한 URL을 생성하는 데 사용됩니다. 

페이지 제목 뒤, 콘텐츠 앞, 템플릿은 get_flashed_messages()에서 반환 된 각 메시지를 반복합니다. 뷰에서 flash()를 사용하여 오류 메시지를 표시했으며 이것이이를 표시하는 코드입니다.

여기에 정의 된 세 개의 블록이 다른 템플릿에서 재정의됩니다. 

1. {% block title %}은 브라우저의 탭과 창 제목에 표시되는 제목을 변경합니다.
2. {% block header %}은 제목과 비슷하지만 페이지에 표시되는 제목을 변경합니다.
3. {% block content %}는 로그인 양식이나 블로그 게시물과 같은 각 페이지의 콘텐츠가있는 곳입니다.

기본 템플릿은 templates 디렉토리에 직접 있습니다. 다른 항목을 정리하기 위해 Blueprint의 템플릿은 Blueprint와 동일한 이름의 디렉터리에 배치됩니다.


#### Register 템플릿

{% extends 'base.html'%}은 Jinja에게이 템플릿이 기본 템플릿의 블록을 대체해야한다고 알려줍니다. 렌더링 된 모든 콘텐츠는 기본 템플릿의 블록을 재정의하는 {% block %} 태그 안에 있어야합니다.

여기서 사용되는 유용한 패턴은 {% block header %} 안에 {% block title %}을 배치하는 것입니다. 이것은 제목 블록을 설정 한 다음 그 값을 헤더 블록에 출력하여 창과 페이지가 두 번 쓰지 않고 동일한 제목을 공유하도록합니다.

입력 태그는 여기에서 필수 속성을 사용하고 있습니다. 이는 해당 필드가 채워질 때까지 양식을 제출하지 않도록 브라우저에 지시합니다. 사용자가 해당 속성을 지원하지 않는 이전 브라우저를 사용하고 있거나 요청을 수행하기 위해 브라우저 이외의 것을 사용하는 경우에도 유효성을 검사해야합니다. Flask보기의 데이터. 클라이언트가 일부 유효성 검사를 수행하더라도 항상 서버의 데이터를 완전히 유효성 검사하는 것이 중요합니다.

#### Login 템플릿
제목과 제출 버튼을 제외하고는 Register 템플릿과 동일합니다.


#### 유저 등록

이제 인증 템플릿이 작성되었으므로 사용자를 등록 할 수 있습니다. 서버가 아직 실행 중인지 확인한 다음 (아니면 플라스크 실행) http://127.0.0.1:5000/auth/register로 이동합니다.

양식을 작성하지 않고 "등록"버튼을 클릭하면 브라우저에 오류 메시지가 표시되는지 확인합니다. register.html 템플릿에서 필수 속성을 제거하고 "등록"을 다시 클릭하십시오. 브라우저에서 오류를 표시하는 대신 페이지가 다시로드되고 뷰의 flash () 오류가 표시됩니다.

사용자 이름과 비밀번호를 입력하면 로그인 페이지로 리디렉션됩니다. 잘못된 사용자 이름 또는 올바른 사용자 이름과 잘못된 비밀번호를 입력 해보십시오. 로그인하면 아직 리디렉션 할 색인보기가 없기 때문에 오류가 발생합니다.